import pandas as pd
from radiomics import featureextractor, getFeatureClasses, imageoperations, logging
import radiomics
import os
import SimpleITK as sitk
import numpy as np
import time
import json
from imgtools.io import read_dicom_series
from joblib import Parallel, delayed
from itertools import chain

from pyradiomics.helper_functions import *
from utils.utils import *

def ctsegRadiomicFeatureExtractionParallel(summaryFilePath:str,
                                           summaryJSONPath: str,
                                           pyradiomicsParamFilePath: str,
                                           idColumnName:str,
                                           imageDirPath: str,
                                           segmentationDirPath: str,
                                           segmentationLabel: int = 255,
                                           roiNames: str = None,
                                           outputFilePath: str = None,
                                           parallel: bool = True):
    ''' Perform radiomic feature extraction from CT images with SEG ROI segmentations
    Parameters
    ----------
    summaryFilePath
        Full path, including file name, to summary file containing paths to each matched CT and SEG file (generated in radiogenomic_pipeline)
    
    summaryJSONPath
        Full path, including file name, to summary JSON file generated by med-imagetools autopipeline

    pyradiomicsParamFilePath
        Full path, including file name, to the configuration file for the PyRadiomics feature extraction
    
    idColumnName
        Name of sample ID column
    
    imageDirPath
        Path to the directory containing the image directories containing the CT files. Will be concatenated with the paths contained in
        summaryFilePath 
    
    segmentationDirPath
        Path to the directory containing the segmentation files/directories. Will be concatenated with the paths contained in
        summaryFilePath
    
    segmentationLabel
        Value used to represent the region of interest (ROI) in the segmentation file.

    roiNames
        Identifier for which region(s) of interest (ROI) to load from the segmentation file.

    
    outputFilePath
        Full path, including file name, to save out the extracted radiomics features as a .csv file. If None, nothing is saved out.

    parallel
        bool, whether to run the extraction in parallel or in sequence. Parallel is the default, but in sequence is useful for debugging.
        
    Returns
    -------
    Dataframe containing extracted PyRadiomics features for each sample in summaryFilePath.
    '''

    # Setting pyradiomics verbosity lower
    logger = logging.getLogger("radiomics")
    logger.setLevel(logging.ERROR)

    # Load in summary file generated by radiogenomic_pipeline
    pdSummaryFile = pd.read_csv(summaryFilePath, header=0)
    # Load in JSON file generated by med-imagetools
    with open(summaryJSONPath) as jsonFile:
        summaryJSON = json.load(jsonFile)

    # Get array of unique series' 
    seriesIDs = pdSummaryFile["series_CT"].unique()

    # Load PyRadiomics feature extraction parameters to use
    # Initialize feature extractor with parameters
    featureExtractor = featureextractor.RadiomicsFeatureExtractor(pyradiomicsParamFilePath)

    # Table to store features for each case
    featuresTable = pd.DataFrame()

    # Flag for features table to see if it needs to be initialized before appending results
    emptyFeaturesTable = True

    def featureExtraction(ctSeries):
        ''' Function to extract PyRadiomics features for all ROIs present in a CT. Inner function so it can be run in parallel with joblib.'''
        # Get all rows for this ctSeries
        sampleRows = pdSummaryFile.loc[pdSummaryFile["series_CT"] == ctSeries]
        patID = sampleRows.iloc[0][idColumnName]

        print("Processing ", patID)
        
        # Load CT by passing in specific series to find in a directory
        ctFolderPath = os.path.join(imageDirPath, sampleRows.iloc[0]['folder_CT'])
        ctImage = read_dicom_series(path = ctFolderPath, series_id = ctSeries)

        # Get list of segmentations to iterate over
        segSeriesIDs = sampleRows['series_seg'].unique()

        # Initialize dictionary to store radiomics data for each segmentation
        ctAllData = []

        # Loop over every segmentation associated with this CT - only loading CT once
        for segCount, segSeries in enumerate(segSeriesIDs):
            segRow = sampleRows.loc[sampleRows['series_seg'] == segSeries]

            # Check that a single segmentation file is being processed
            if len(segRow) > 1:
                # Check that if there are multiple rows that it's not due to a CT with subseries (this is fine, the whole series is loaded)
                if not segRow.duplicated(subset=['series_CT'], keep=False).all():
                    raise RuntimeError("Some kind of duplication of segmentation and CT matches not being caught. Check seg_and_ct_dicom_list in radiogenomic_output.")
            
            # Get path to DICOM folder for CT and SEG
            # Full path is not included in summary file, need to add base of path
            # Need ctFolderPath for loading RTSTRUCTS
            # ctFolderPath = os.path.join(imageDirPath, segRow.iloc[0]['folder_CT'])
            segFilePath = os.path.join(segmentationDirPath, segRow.iloc[0]['file_path_seg'])

            # Get dictionary of ROI sitk Images for this segmentation file
            segImages = loadSegmentation(segFilePath, modality = segRow.iloc[0]['modality_seg'], originalImageDirPath=ctFolderPath, roiNames=roiNames)

            # Check that this series has ROIs to extract from (dictionary isn't empty)
            if not segImages:
                print('CT ', ctSeries, 'and segmentation ',segSeries, ' has no ROIs or no ROIs with the label ', roiNames, '. Moving to next segmentation.')

            else:
                # Initialize dictionary to store radiomics data for each ROI in this segmentation
                segAllData = {}
                # Loop over each ROI contained in the segmentation to perform radiomic feature extraction
                for roiCount, roi in enumerate(segImages):
                    roiNum = roiCount + 1
                    
                    # Segmentation contains extra axis, flatten to 3D by removing it
                    roiImage = flattenImage(segImages[roi])
                    # Segmentation has different origin, align it to the CT for proper feature extraction
                    alignedROIImage = alignImages(ctImage, roiImage)

                    # Exception catch for if the segmentation dimensions do not match that original image
                    try:
                        # Check that image and segmentation mask have the same dimensions
                        if ctImage.GetSize() != alignedROIImage.GetSize():
                            # Checking if number of segmentation slices is less than CT 
                            if ctImage.GetSize()[2] > alignedROIImage.GetSize()[2]:  
                                print("Slice number mismatch between CT and segmentation for", patID, ". Padding segmentation to match.")
                                alignedROIImage = padSEGtoMatchCT(ctFolderPath, segFilePath, ctImage, alignedROIImage)
                            else:
                                raise RuntimeError()

                        # Check that image and segmentation mask correspond
                        segBoundingBox, correctedROIImage = imageoperations.checkMask(ctImage, alignedROIImage, label=segmentationLabel)
                        if correctedROIImage is not None:
                            alignedROIImage = correctedROIImage
                        
                        # Crop the image and mask to a bounding box around the mask to reduce amount of slices to process
                        croppedImage, croppedROI = imageoperations.cropToTumorMask(ctImage, alignedROIImage, segBoundingBox)
                    
                        # Extract features listed in the parameter file
                        print('Calculating features for patient:', patID, ", segmentation:", roi)

                        # Extract radiomic features from CT with segmentation as mask, with segmentation pixels set to 255 by default
                        idFeatureVector = featureExtractor.execute(croppedImage, croppedROI, label=segmentationLabel)

                        # Add image info to beginning of table
                        sampleROIData = {"patient_ID": patID,
                                        "study_UID": segRow.iloc[0]['study_CT'],
                                        "study_description": segRow.iloc[0]['study_description_CT'],
                                        "series_UID": segRow.iloc[0]['series_CT'],
                                        "series_description": segRow.iloc[0]['series_description_CT'],
                                        "image_modality": segRow.iloc[0]['modality_CT'],
                                        "instances": segRow.iloc[0]['instances_CT'],
                                        "seg_series_UID": segRow.iloc[0]['series_seg'],
                                        "seg_modality": segRow.iloc[0]['modality_seg'],
                                        "seg_ref_image": segRow.iloc[0]['reference_ct_seg'],
                                        "roi": roi,
                                        "roi_number": roiNum}

                        # Add pyradiomic output to the end of the dictionary
                        sampleROIData.update(idFeatureVector)
                        # Store this ROI's info in the segmentation level list
                        ctAllData.append(sampleROIData)

                    except Exception as e:
                        print(str(e))

        return ctAllData

    # Extract radiomic features, get a list of dictionaries
    # Each dictionary contains features for each ROI in a single CT
    if not parallel:
        # Run feature extraction over samples in sequences - will be slower
        features = [featureExtraction(ctSeries) for ctSeries in seriesIDs]
    else:
        # Run feature extraction in parallel
        features = Parallel(n_jobs=-1, require='sharedmem')(delayed(featureExtraction)(ctSeries) for ctSeries in seriesIDs)
  
    # Flatten the list of dictionaries (happens when there are multiple ROIs or SEGs associated with a single CT)
    flatFeatures = list(chain.from_iterable(features))
    # Convert list of feature sets into a pandas dataframe to save out
    featuresTable = pd.DataFrame(flatFeatures)     

    # Save out features
    if outputFilePath != None:
        # Make directory if it doesn't exist
        if not os.path.exists(os.path.dirname(outputFilePath)):
            os.makedirs(os.path.dirname(outputFilePath))
        # Save out feature set
        featuresTable.to_csv(outputFilePath, index=False)

    return featuresTable

